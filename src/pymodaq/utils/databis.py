# -*- coding: utf-8 -*-
"""
Created the 28/10/2022

@author: Sebastien Weber
"""
import numbers
from collections import OrderedDict
import numpy as np
from typing import List, Union
import warnings
from time import time

from pymodaq.utils.daq_enums import BaseEnum


class DataShapeError(Exception):
    pass


class DataLengthError(Exception):
    pass


class DataDim(BaseEnum):
    """Enum for dimensionality representation of data"""
    Data0D = 0
    Data1D = 1
    Data2D = 2
    DataND = 3


class DataSource(BaseEnum):
    """Enum for source of data"""
    raw = 0
    roi = 1
    calculated = 2


class Axis:
    def __init__(self, label: str = '', units: str = '', data: np.ndarray = None, nav_index: int = -1):
        super().__init__()
        if not isinstance(label, str):
            raise TypeError('label for the Axis class should be a string')

        if not isinstance(units, str):
            raise TypeError('units for the Axis class should be a string')

        self.units = units
        self.label = label
        self.data = data
        self.nav_index = nav_index


class DataBase:
    """Base object to store homogeneous data and metadata generated by pymodaq's objects

    Parameters
    ----------
    name: str
        the identifier of these data
    source: DataSource
        Enum specifying if data are raw or processed (for instance from roi)
    dim: DataDim
        The identifier of the data type
    data: list of ndarray
        The data the object is storing
    kwargs
    """

    def __init__(self, name: str, source: DataSource, dim: DataDim = None, data: List[np.ndarray] = None, **kwargs):

        super().__init__()

        self._shape = None
        self._size = None
        self._data = None
        self._timestamp = time()
        self._length = None

        if not isinstance(source, DataSource):
            raise TypeError(f'{source} is an invalid source for these data. Should be in {DataSource.names()}')
        if not isinstance(dim, DataDim) or None:
            raise TypeError(f'{dim} is an invalid Data dimensionality. Should be in {DataDim.names()}')

        self._name = name
        self._source = source
        self._dim = dim
        self.data = data

        for key in kwargs:
            setattr(self, key, kwargs[key])

    @property
    def timestamp(self):
        """The timestamp when the object has been created"""
        return self._timestamp

    @property
    def shape(self):
        """The shape of the nd-arrays"""
        return self._shape

    @property
    def size(self):
        """The size of the nd-arrays"""
        return self._size

    @property
    def dim(self):
        """DataDim: the enum representing the dimensionality of the stored data"""
        return self._dim

    @property
    def name(self):
        """str: the identifier of the data"""
        return self._name

    @property
    def source(self):
        """DataSource: the enum representing the source of the data"""
        return self._source

    @property
    def length(self):
        """The length of data. This is the length of the list containing the nd-arrays"""
        return self._length

    @staticmethod
    def _check_data_type(data: List[np.ndarray]):
        """make sure data is a list of nd-arrays"""
        is_valid = True
        if data is None:
            is_valid = False
        if not isinstance(data, list):
            is_valid = False
        if isinstance(data, list):
            if len(data) == 0:
                is_valid = False
            if not isinstance(data[0], np.ndarray):
                is_valid = False
            elif len(data[0].shape) == 0:
                is_valid = False
        if not is_valid:
            raise TypeError(f'Data should be an non-empty list of an non-empty numpy arrays')

    def get_dim_from_data(self, data: List[np.ndarray]):
        """Get the dimensionality DataDim from data"""
        self._shape = data[0].shape
        self._size = data[0].size
        self._length = len(data)
        if len(self._shape) == 1 and self._size == 1:
            dim = DataDim['Data0D']
        elif len(self._shape) == 1 and self._size > 1:
            dim = DataDim['Data1D']
        elif len(self._shape) == 2:
            dim = DataDim['Data2D']
        else:
            dim = DataDim['DataND']
        return dim

    def _check_shape_dim_consistency(self, data: List[np.ndarray]):
        """Process the dim from data or make sure data and DataDim are coherent"""
        dim = self.get_dim_from_data(data)
        if self._dim is None:
            self._dim = dim
        else:
            if self._dim != dim:
                warnings.warn('The specified dimensionality is not coherent with the data shape')
                self._dim = dim

    def _check_same_shape(self, data: List[np.ndarray]):
        """Check that all nd-arrays have the same shape"""
        for dat in data:
            if dat.shape != self.shape:
                raise DataShapeError('The shape of the ndarrays in data is not the same')

    @property
    def data(self):
        """List[np.ndarray]: get/set (and check) the data the object is storing"""
        return self._data

    @data.setter
    def data(self, data: list[np.ndarray]):
        self._check_data_type(data)
        self._check_shape_dim_consistency(data)
        self._check_same_shape(data)
        self._data = data


class DataMetadata(DataBase):
    def __init__(self, name: str, source: DataSource, dim: DataDim = None, data: List[np.ndarray] = None,
                 labels: List[str] = [], axes: List[Axis] = [], **kwargs):
        super().__init__(name, source, dim, data, **kwargs)

        self._labels = None

        self._check_labels()
        for axis in axes:
            self._check_axis(axis)

    def _check_axis(self, axis, dim=0, ):

    @property
    def labels(self):
        return self._labels

    def _check_labels(self, labels):
        while len(labels) < self.length:
            labels.append(f'CH{len(labels) - 1:02d}')
        self._labels = labels

