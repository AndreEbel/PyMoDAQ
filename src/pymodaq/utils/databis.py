# -*- coding: utf-8 -*-
"""
Created the 28/10/2022

@author: Sebastien Weber
"""
import numbers
from collections import OrderedDict
import numpy as np
from typing import List, Union
import warnings
from time import time

from pymodaq.utils.daq_enums import BaseEnum


class DataShapeError(Exception):
    pass


class DataLengthError(Exception):
    pass


class DataDim(BaseEnum):
    """Enum for dimensionality representation of data"""
    Data0D = 0
    Data1D = 1
    Data2D = 2
    DataND = 3


class DataSource(BaseEnum):
    """Enum for source of data"""
    raw = 0
    calculated = 2


class AxisBase:
    """Object holding info and data about physical axis of data

    Parameters
    ----------
    label: str
        The label of the axis, for instance 'time' for a temporal axis
    units: str
        The units of the data in the object, for instance 's' for seconds
    data: ndarray
        A 1D ndarray holding the data of the axis
    index: int
        a integer representing the index of the Data object this axis is related to
    """

    def __init__(self, label: str = '', units: str = '', data: np.ndarray = None, index: int = 0):
        super().__init__()
        self._size = None
        self._data = None
        self._index = None
        self._label = None
        self._units = None

        self.units = units
        self.label = label
        self.data = data
        self.index = index

    @property
    def label(self) -> str:
        """str: get/set the label of this axis"""
        return self._label

    @label.setter
    def label(self, lab: str):
        if not isinstance(lab, str):
            raise TypeError('label for the Axis class should be a string')
        self._label = lab

    @property
    def units(self) -> str:
        """str: get/set the units for this axis"""
        return self._units

    @units.setter
    def units(self, units: str):
        if not isinstance(units, str):
            raise TypeError('units for the Axis class should be a string')
        self._units = units

    @property
    def index(self) -> int:
        """int: get/set the index this axis corresponds to in a DataWithAxis object"""
        return self._index

    @index.setter
    def index(self, ind: int):
        self._check_index_valid(ind)
        self._index = ind

    @property
    def data(self):
        """np.ndarray: get/set the data of Axis"""
        return self._data

    @data.setter
    def data(self, dat: np.ndarray):
        self._check_data_valid(dat)
        self._data = dat
        self._size = dat.size

    @property
    def size(self) -> int:
        """int: the size/length of the 1D ndarray"""
        return self._size

    @staticmethod
    def _check_index_valid(index: int):
        if not isinstance(index, int):
            raise TypeError('index for the Axis class should be a positive integer')
        elif index < 0:
            raise ValueError('index for the Axis class should be a positive integer')

    @staticmethod
    def _check_data_valid(data):
        if data is None:
            raise ValueError(f'data for the Axis class should be a 1D numpy array')
        elif not isinstance(data, np.ndarray):
            raise TypeError(f'data for the Axis class should be a 1D numpy array')
        elif len(data.shape) != 1:
            raise ValueError(f'data for the Axis class should be a 1D numpy array')

    def create_linear_data(self, dim):
        """replace the axis data with a linear version of dim steps of size 1"""
        self.data = np.linspace(0, dim-1, dim)

    def __len__(self):
        return self.data.size

    def __getitem__(self, item):
        """For back compatibility when axis was a dict"""
        if hasattr(self, item):
            return getattr(self, item)

    def __repr__(self):
        return f'{self.__class__.__name__}: <label: {self.label}> - <units: {self.units}> - <index: {self.index}>'

    def __mul__(self, scale: numbers.Real):
        if isinstance(scale, numbers.Real):
            return self.__class__(data=self.data * scale, label=self.label, units=self.units, index=self.index)

    def __add__(self, offset: numbers.Real):
        if isinstance(offset, numbers.Real):
            return self.__class__(data=self.data + offset, label=self.label, units=self.units, index=self.index)

    def __eq__(self, other):
        eq = self.label == other.label
        eq = eq and (self.units == other.units)
        eq = eq and (np.any(np.abs(self.data - other.data) < 1e-10))
        eq = eq and (self.index == other.index)
        return eq


class Axis(AxisBase):
    """Axis object to be used to described physical axes of data"""
    def __init__(self, label: str = '', units: str = '', data: np.ndarray = None, index: int = -1):
        super().__init__(label, units, data, index)


class DataBase:
    """Base object to store homogeneous data and metadata generated by pymodaq's objects. To be inherited for real data

    Parameters
    ----------
    name: str
        the identifier of these data
    source: DataSource or str
        Enum specifying if data are raw or processed (for instance from roi)
    dim: DataDim or str
        The identifier of the data type
    data: list of ndarray
        The data the object is storing
    labels: list of str
        The labels of the data nd-arrays
    kwargs
    """

    def __init__(self, name: str, source: DataSource, dim: DataDim = None, data: List[np.ndarray] = None,
                 labels: List[str] = [], **kwargs):

        super().__init__()

        self._shape = None
        self._size = None
        self._data = None
        self._timestamp = time()
        self._length = None
        self._labels = None

        if not isinstance(source, DataSource):
            if source in DataSource.names():
                source = DataSource[source]
            else:
                raise TypeError(f'{source} is an invalid source for these data. Should be a DataSource enum or a string'
                                f' in {DataSource.names()}')
        if not isinstance(dim, DataDim):
            if dim is not None:
                if dim in DataDim.names():
                    dim = DataDim[dim]
                else:
                    raise ValueError(f'{dim} is an invalid Data dimensionality. Should be a DataDim enum or a string in'
                                     f' {DataDim.names()}')

        self._name = name
        self._source = source
        self._dim = dim
        self.data = data

        self._check_labels(labels)
        for key in kwargs:
            setattr(self, key, kwargs[key])

    @property
    def timestamp(self):
        """The timestamp when the object has been created"""
        return self._timestamp

    @property
    def shape(self):
        """The shape of the nd-arrays"""
        return self._shape

    @property
    def size(self):
        """The size of the nd-arrays"""
        return self._size

    @property
    def dim(self):
        """DataDim: the enum representing the dimensionality of the stored data"""
        return self._dim

    @property
    def name(self):
        """str: the identifier of the data"""
        return self._name

    @property
    def source(self):
        """DataSource: the enum representing the source of the data"""
        return self._source

    @property
    def length(self):
        """The length of data. This is the length of the list containing the nd-arrays"""
        return self._length

    @property
    def labels(self):
        return self._labels

    def _check_labels(self, labels):
        while len(labels) < self.length:
            labels.append(f'CH{len(labels):02d}')
        self._labels = labels

    def get_data_index(self, index: int = 0):
        """Get the data by its index in the list"""
        return self.data[index]

    @staticmethod
    def _check_data_type(data: List[np.ndarray]):
        """make sure data is a list of nd-arrays"""
        is_valid = True
        if data is None:
            is_valid = False
        if not isinstance(data, list):
            is_valid = False
        if isinstance(data, list):
            if len(data) == 0:
                is_valid = False
            if not isinstance(data[0], np.ndarray):
                is_valid = False
            elif len(data[0].shape) == 0:
                is_valid = False
        if not is_valid:
            raise TypeError(f'Data should be an non-empty list of an non-empty numpy arrays')

    def get_dim_from_data(self, data: List[np.ndarray]):
        """Get the dimensionality DataDim from data"""
        self._shape = data[0].shape
        self._size = data[0].size
        self._length = len(data)
        if len(self._shape) == 1 and self._size == 1:
            dim = DataDim['Data0D']
        elif len(self._shape) == 1 and self._size > 1:
            dim = DataDim['Data1D']
        elif len(self._shape) == 2:
            dim = DataDim['Data2D']
        else:
            dim = DataDim['DataND']
        return dim

    def _check_shape_dim_consistency(self, data: List[np.ndarray]):
        """Process the dim from data or make sure data and DataDim are coherent"""
        dim = self.get_dim_from_data(data)
        if self._dim is None:
            self._dim = dim
        else:
            if self._dim != dim:
                warnings.warn(UserWarning('The specified dimensionality is not coherent with the data shape'))
                self._dim = dim

    def _check_same_shape(self, data: List[np.ndarray]):
        """Check that all nd-arrays have the same shape"""
        for dat in data:
            if dat.shape != self.shape:
                raise DataShapeError('The shape of the ndarrays in data is not the same')

    @property
    def data(self):
        """List[np.ndarray]: get/set (and check) the data the object is storing"""
        return self._data

    @data.setter
    def data(self, data: List[np.ndarray]):
        self._check_data_type(data)
        self._check_shape_dim_consistency(data)
        self._check_same_shape(data)
        self._data = data


class DataWithAxis(DataBase):
    """Data object with Axis object corresponding to underlying data nd-arrays

    Parameters
    ----------
    axes: list of Axis
        the list of Axis object for proper plotting, calibration ...

    """
    def __init__(self, name: str, source: DataSource, dim: DataDim = None, data: List[np.ndarray] = None,
                 labels: List[str] = [], axes: List[Axis] = [], **kwargs):
        super().__init__(name, source, dim, data, labels, **kwargs)

        self._axes: List[Axis] = None
        self._check_axis(axes)

    @property
    def axes(self):
        return self._axes

    def _check_axis(self, axes):
        for ind, axis in enumerate(axes):
            if not isinstance(axis, Axis):
                raise TypeError(f'An axis of {self.__class__.name} should be an Axis object')
            if self.get_shape_from_index(axis.index) != axis.size:
                warnings.warn(UserWarning('The size of the axis is not coherent with the shape of the data. Replacing it '
                              'with an index version: 0, 1, 2, ...'))
                axes[ind].create_linear_data(self.get_shape_from_index(axis.index))
        self._axes = axes

    def get_shape_from_index(self, index):
        if index > len(self.shape) or index < 0:
            raise IndexError('The specified index does not correspond to any data dimension')
        return self.shape[index]

    def get_axis_from_index(self, index: int):
        if index > len(self.shape) or index < 0:
            raise IndexError('The specified index does not correspond to any data dimension')
        for axis in self.axes:
            if axis.index == index:
                return axis
        warnings.warn(UserWarning(f'The axis requested with index {index} is not present, creating a linear one...'))
        axis = Axis(data = np.zeros((1,)), index=index)
        axis.create_linear_data(self.get_shape_from_index(index))
        return axis


class DataRaw(DataWithAxis):
    """Specialized DataWithAxis set with source as 'raw'. To be used for raw data"""
    def __init__(self, name: str, dim: DataDim = None, data: List[np.ndarray] = None,
                 labels: List[str] = [], axes: List[Axis] = [], **kwargs):
        super().__init__(name, source=DataSource['raw'], dim=dim, data=data, labels=labels, axes=axes,  **kwargs)


class DataFromPlugins(DataRaw):
    """Specialized DataWithAxis set with source as 'raw'. To be used for raw data generated by plugins"""
    def __init__(self, name: str, dim: DataDim = None, data: List[np.ndarray] = None,
                 labels: List[str] = [], axes: List[Axis] = [], **kwargs):
        super().__init__(name, dim=dim, data=data, labels=labels, axes=axes, **kwargs)


class DataCalulated(DataWithAxis):
    """Specialized DataWithAxis set with source as 'calculated'. To be used for processed/calculated data"""
    def __init__(self, name: str, dim: DataDim = None, data: List[np.ndarray] = None,
                 labels: List[str] = [], axes: List[Axis] = [], **kwargs):
        super().__init__(name, source=DataSource['calculated'], dim=dim, data=data, labels=labels, axes=axes, **kwargs)


class DataFromRoi(DataCalulated):
    """Specialized DataWithAxis set with source as 'calculated'.To be used for processed data from region of interest"""
    def __init__(self, name: str, dim: DataDim = None, data: List[np.ndarray] = None,
                 labels: List[str] = [], axes: List[Axis] = [], **kwargs):
        super().__init__(name, dim=dim, data=data, labels=labels, axes=axes, **kwargs)



