
:mod:`DAQ_utils`
================

.. py:module:: DAQ_utils









Module Contents
---------------





.. function:: my_moment(x,y)

   







.. function:: odd_even(x)

   
   odd_even tells if a number is odd (return True) or even (return False)

   :param x:
   :type x: the integer number to test

   :returns: **bool**
   :rtype: boolean

   







.. function:: set_scan_spiral(start_axis1,start_axis2,rmax,rstep)

   
   Set a spiral scan of a 0D Data aquisition.

   =============== ========== ==========================================
   **Parameters**   **Type**   **Description**
   *start_axis1*    int        The starting value of the first sequence
   *start_axis2*    int        The starting value of the second sequence
   *rmax*           int        The end point
   *rstep*          int        The value of one step
   =============== ========== ==========================================

   :returns:

             The tuple containing :
              * the number of steps
              * the first axis indexes
              * the second axis indexes
              * the first axis with unique values
              * the second axis with unique values
              * the first axis
              * the second axis
              * the positions float values
   :rtype: (int,int list,int list,float list,float list,float list,list of 2 float lists) tuple

   .. rubric:: Examples

   >>> import DAQ_utils as Du
   >>> start_axis1,start_axis2=1,1
   >>> rmax=2
   >>> rstep=1
   >>> spiral_scan=Du.set_scan_spiral(start_axis1,start_axis2,rmax,rstep)
   >>> print(spiral_scan[0])       #The number of step
   25
   >>> print(spiral_scan[1])       #The first distributed axis
   [-1  0  1  2  3]
   >>> print(spiral_scan[2])       #The second distributed axis
   [-1  0  1  2  3]
   >>> print(spiral_scan[3])       #The positions scalar list computed
   [[1, 1], [2, 1], [2, 2], [1, 2], [0, 2],
   [0, 1], [0, 0], [1, 0], [2, 0], [3, 0],
   [3, 1], [3, 2], [3, 3], [2, 3], [1, 3],
   [0, 3], [-1, 3], [-1, 2], [-1, 1], [-1, 0],
   [-1, -1], [0, -1], [1, -1], [2, -1], [3, -1]]

   







.. function:: linspace_step(start,stop,step)

   
   Compute a regular linspace_step distribution from start to stop values.

   =============== =========== ======================================
   **Parameters**    **Type**    **Description**
   *start*            scalar      the starting value of distribution
   *stop*             scalar      the stopping value of distribution
   *step*             scalar      the length of a distribution step
   =============== =========== ======================================

   :returns: The computed distribution axis as an array.
   :rtype: scalar array

   .. rubric:: Examples

   >>> import DAQ_utils as Du
   >>> import numpy as np
   >>>    #arguments initializing
   >>> start=0
   >>> stop=5
   >>> step=0.25
   >>> linspace_distribution=Du.linspace_step(start,stop,step)
   >>> print(linspace_distribution)
   >>>    #computed distribution
   [ 0.    0.25  0.5   0.75  1.    1.25  1.5   1.75  2.    2.25  2.5   2.75
     3.    3.25  3.5   3.75  4.    4.25  4.5   4.75  5.  ]

   







.. function:: set_scan_linear(start_axis1,start_axis2,stop_axis1,stop_axis2,step_axis1,step_axis2,back_and_force=False)

   
   Set a linear scan of a 0D Data aquisition.
   The positions scalar list is computed by a Cartesian product of the first distributed axis and the second one.

   The result size is composed by :
   * a single integer representing the number of step
   * a n items integer array representing the first distributed axis
   * a k items integer array representing the second distributed axis
   * a n*k items containing the combinaisons of the first and the second axis distribution.

   ================ ========== =============================================
   **Parameters**    **Type**   **Description**
   *start_axis1*     scalar     The starting value of the first sequence
   *start_axis2*     scalar     The starting value of the second sequence
   *stop_axis1*      scalar     The end point of the first sequence
   *stop_axis2*      scalar     The end point of the second sequence
   *step_axis1*      float      The value of one step of the first sequence
   *step_axis2*     float      The value of one step of the second sequence
   *back_and_force*  boolean    ???
   ================ ========== =============================================


   :returns:

             The tuple containing:
              * The number of step
              * The first distributed axis
              * The second distributed axis
              * The positions scalar list computed
   :rtype: (int,float list,float list,scalar list) tuple

   .. rubric:: Examples

   ..doctest::

       >>> import DAQ_utils as Du
       >>> start_axis1,start_axis2=1,1
       >>> stop_axis1,stop_axis2=3,3
       >>> step_axis1,step_axis2=1,1
       >>> linear_scan=Du.set_scan_linear(start_axis1,start_axis2,stop_axis1,stop_axis2,step_axis1,step_axis2)
       >>> print(linear_scan[0])       #The number of step
       9
       >>> print(linear_scan[1])       #The first distributed axis
       [1 2 3]
       >>> print(linear_scan[2])       #The second distributed axis
       [1 2 3]
       >>> print(linear_scan[3])       #The positions scalar list computed
       [[1, 1], [1, 2], [1, 3], [2, 1], [2, 2], [2, 3], [3, 1], [3, 2], [3, 3]]

   







.. function:: find_part_in_path_and_subpath(base_dir,part="",create=False)

   
   Find path from part time.

   =============== ============ =============================================
   **Parameters**  **Type**      **Description**
   *base_dir*      Path object   The directory to browse
   *part*          string        The date of the directory to find/create
   *create*        boolean       Indicate the creation flag of the directory
   =============== ============ =============================================

   :returns: found path from part
   :rtype: Path object

   .. rubric:: Examples

   ..doctest::

       >>> import DAQ_utils as Du
       >>> import pathlib as pl
       >>> base_dir=pl.Path("") #Getting the current path
       >>> print(base_dir)
       .
       >>> path=Du.find_part_in_path_and_subpath(base_dir,"2018",True)
       >>> print(path)       #Path of created directory "2018"
       2018
       >>> path=Du.find_part_in_path_and_subpath(base_dir,"2017",False)
       >>> print(path)       #Path is none since "2017" dir doesn't exist
       None
       >>> path=Du.find_part_in_path_and_subpath(base_dir,"2018",False)
       >>> print(path)       #Path of directory "2018"
       2018

   







.. function:: set_current_scan_path(base_dir,base_name="Scan",update_h5=False)

   
   Set the path of the current scan and create associated directory tree.
   As default :

   Year/Date/Dataset_Date_ScanID/ScanID


   =============== ============ =====================================
   **Parameters**  **Type**      **Description**
   base_dir        Path object   The base directory
   base_name       string        Name of the current scan
   update_h5       boolean       1/0 to update the associated h5 file
   =============== ============ =====================================

   :returns: indexed base_name, new folder indexed from base name at the day
   :rtype: scan_path

   .. seealso:: :func:`DAQ_utils.find_part_in_path_and_subpath`

   .. rubric:: Examples

   ..doctest::

       >>> import DAQ_utils as Du
       >>> import pathlib as pl
       >>> base_dir=pl.Path("") #Getting the current path
       >>>
       >>> current_scan_path=Du.set_current_scan_path(base_dir)
       >>>  #Function call with default name
       >>> print(current_scan_path[0])       #The full scan path
       2018\20180424\Dataset_20180424_000\Scan000
       >>> print(current_scan_path[1])       #The indexed base name
       Scan000
       >>> print(current_scan_path[2])       #The dataset_path
       2018\20180424\Dataset_20180424_000
       >>>
       >>> current_scan_path=Du.set_current_scan_path(base_dir,'Specific name')
       >>> #Function call with a specific name
       >>> print(current_scan_path[0])       #The full scan path
       2018\20180424\Dataset_20180424_000\Specific name000
       >>> print(current_scan_path[1])       #The indexed base name
       Specific name000
       >>> print(current_scan_path[2])       #The dataset_path
       2018\20180424\Dataset_20180424_000

   







.. function:: select_file(start_path=None,save=True,ext="h5")

   
   Save or open a file with Qt5 file dialog, to be used within an Qt5 loop.

   =============== ======================================= ===========================================================================
   **Parameters**     **Type**                              **Description**

   *start_path*       Path object or str or None, optional  the path Qt5 will open in te dialog
   *save*             bool, optional                        * if True, a savefile dialog will open in order to set a savefilename
                                                            * if False, a openfile dialog will open in order to open an existing file
   *ext*              str, optional                         the extension of the file to be saved or opened
   =============== ======================================= ===========================================================================

   :returns: the Path object pointing to the file
   :rtype: Path object

   .. rubric:: Examples

   >>>from PyQt5 import QtWidgets
   >>>from DAQ.DAQ_Utils.DAQ_utils import select_file
   >>>import sys
   >>>app = QtWidgets.QApplication(sys.argv)
   >>>    #Open a save windows
   >>>select_file(start_path="C:/test",save=False,ext='h5')
   >>>sys.exit(app.exec_())

   







.. function:: find_index(x,threshold)

   
   find_index finds the index ix such that x(ix) is the closest from threshold

   :param x:
   :type x: vector
   :param threshold:
   :type threshold: list of scalar

   :returns: **out** -- out=[(ix0,xval0),(ix1,xval1),...]
   :rtype: list of 2-tuple containing ix,x[ix]

   .. rubric:: Examples

   >>> import array_manipulation as am
   >>> import numpy as np
   >>>    #vector creation
   >>> x_vector=np.array([1,2,3])
   >>> index=am.find_index(x_vector,4)
   >>>    #the nearest index from threshold
   >>> print(index)
   >>>    #ix=2, x[2]=3  , threshold=4
   [(2, 3)]
   >>>
   >>> x_vector=np.array([1,2,3,4,5,6,7,8,9,10])
   >>> index=am.find_index(x_vector,[3.8,7.5,12.])
   >>>    #the nearest indexs from threshold list [3.8,7.5,12.]
   >>> print(index)
   >>>    #ix0=3, x[3]=4  , threshold=3.8
   >>>    #ix1=6, x[6]=7  , threshold=7.5
   >>>    #ix2=9, x[9]=10 , threshold=12.0
   [(3, 4), (6, 7), (9, 10)]

   







.. function:: gauss1D(x,x0,dx,n=1)

   
   compute the gaussian function along a vector x, centered in x0 and with a
   FWHM i intensity of dx. n=1 is for the standart gaussian while n>1 defines
   a hypergaussian

   =============== =========== ============================================================
   **Parameters**    **Type**    **Description**
   *x*               vector      vector
   *x0*              float       the central position of the gaussian
   *dx*              float       the FWHM of the gaussian
   *n*               float       define hypergaussian, n=1 by default for regular gaussian
   =============== =========== ============================================================

   :returns: **out** -- the value taken by the gaussian along x axis
   :rtype: vector

   .. rubric:: Examples

   >>> import DAQ_utils as Du
   >>> import numpy as np
   >>> x=np.array([0,1,2,3,4])            #argument initializing
   >>> x0=2
   >>> dx=0.5
   >>> gaussian_distribution=Du.gauss1D(x,x0,dx)
   >>> print(gaussian_distribution)       #The computed gaussian distribution
   [  2.32830644e-10   3.90625000e-03   1.00000000e+00   3.90625000e-03
      2.32830644e-10]

   







.. function:: gauss2D(x,x0,dx,y,y0,dy,n=1)

   
   compute the 2D gaussian function along a vector x, centered in x0 and with a
   FWHM in intensity of dx and smae along y axis. n=1 is for the standart gaussian while n>1 defines
   a hypergaussian

   =============== =========== ===========================================================
   **Parameters**    **Type**    **Description**
   *x*               vector      the x_axis
   *x0*              float       the central position of the gaussian on x_axis
   *dx*              float       the FWHM of the gaussian on x_axis
   *y*               vector      the y_axis
   *y0*              float       the central position of the gaussian on y_axis
   *dy*              float       the FWHM of the gaussian on y_axis
   *n*               float       define hypergaussian, n=1 by default for regular gaussian
   =============== =========== ===========================================================

   :returns: **out** -- the value taken by the gaussian along x axis
   :rtype: vector

   .. rubric:: Examples

   >>> import DAQ_utils as Du
   >>> import numpy as np
   >>>    #arguments initializing
   >>> x,y=np.array([0,1,2,3,4]),np.array([0,1,2,3,4])
   >>> x0,y0=2,2
   >>> dx,dy=0.5,0.5
   >>> gaussian_distribution=Du.gauss2D(x,x0,dx,y,y0,dy)
   >>>    #the computed 2d gaussian distribution
   >>> print(gaussian_distribution)
   [[  5.42101086e-20   9.09494702e-13   2.32830644e-10   9.09494702e-13
       5.42101086e-20]
    [  9.09494702e-13   1.52587891e-05   3.90625000e-03   1.52587891e-05
       9.09494702e-13]
    [  2.32830644e-10   3.90625000e-03   1.00000000e+00   3.90625000e-03
       2.32830644e-10]
    [  9.09494702e-13   1.52587891e-05   3.90625000e-03   1.52587891e-05
       9.09494702e-13]
    [  5.42101086e-20   9.09494702e-13   2.32830644e-10   9.09494702e-13
       5.42101086e-20]]

   







.. function:: ftAxis_time(Npts,time_max)

   
   Given two numbers Npts,omega_max, return two vectors spanning the temporal
   and spectral range. They are related by Fourier Transform

   =============== =========== ===========================================================================
   **Parameters**    **Type**    **Description**
   *Npts*            int          A number of points defining the length of both grids
   *time_max*       float         The maximum circular frequency in the spectral domain. its unit defines
                                  the temporal units. ex: omega_max in rad/fs implies time_grid in fs
   =============== =========== ===========================================================================

   :returns: * **omega_grid** (*vector*) -- The spectral axis of the FFT
             * **time_grid** (*vector*) -- The temporal axis of the FFT

   .. rubric:: Example

   >>> (omega_grid, time_grid)=ftAxis(Npts,omega_max)
   ...

   







.. function:: ft(x,dim=0)

   







.. function:: ift(x,dim=0)

   





.. py:class:: ThreadCommand(command="",attributes=list)

   | Micro class managing the thread commands.
   |
   | A thread command is composed of a string name defining the command to execute and an attribute list splitable making arguments of the called function.

   =============== =============
   **Attributes**  **Type**
   *command*       string
   *attributes*    generic list
   =============== =============

   .. rubric:: Examples

   ..doctest::

       >>> import DAQ_utils as Du
       >>> thread_command_ex=Du.ThreadCommand("The command name",
       ... ["differents","attributes","here"])
       >>>   #The thread command memory location
       >>> print(thread_command_ex)
       <DAQ_utils.ThreadCommand object at 0x000000000A390B38>
       >>>   #A command name
       >>> print(thread_command_ex.command)
       The command name
       >>>   #the attributes treated as parameter once the command treated
       >>> print(thread_command_ex.attributes)
       ['differents', 'attributes', 'here']
       >>>   #Attributes type is generic
       >>> thread_command_ex=Du.ThreadCommand("The command name",
       ... [10,20,30,40,50])
       >>>   #A different memory location
       >>> print(thread_command_ex)
       <DAQ_utils.ThreadCommand object at 0x0000000005372198>
       >>>   #A command name
       >>> print(thread_command_ex.command)
       The command name
       >>>   #With new attributes
       >>> print(thread_command_ex.attributes)
       [10, 20, 30, 40, 50]


   

   

   

   .. method:: __init__(command="",attributes=list)

      


   


